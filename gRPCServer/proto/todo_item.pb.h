// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: todo_item.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_todo_5fitem_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_todo_5fitem_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_todo_5fitem_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_todo_5fitem_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_todo_5fitem_2eproto;
namespace todo_item {
class CreateTodoItemRequest;
struct CreateTodoItemRequestDefaultTypeInternal;
extern CreateTodoItemRequestDefaultTypeInternal _CreateTodoItemRequest_default_instance_;
class CreateTodoItemResponse;
struct CreateTodoItemResponseDefaultTypeInternal;
extern CreateTodoItemResponseDefaultTypeInternal _CreateTodoItemResponse_default_instance_;
class DeleteTodoItemRequest;
struct DeleteTodoItemRequestDefaultTypeInternal;
extern DeleteTodoItemRequestDefaultTypeInternal _DeleteTodoItemRequest_default_instance_;
class DeleteTodoItemResponse;
struct DeleteTodoItemResponseDefaultTypeInternal;
extern DeleteTodoItemResponseDefaultTypeInternal _DeleteTodoItemResponse_default_instance_;
class GetTodoItemsByTodoListIdRequest;
struct GetTodoItemsByTodoListIdRequestDefaultTypeInternal;
extern GetTodoItemsByTodoListIdRequestDefaultTypeInternal _GetTodoItemsByTodoListIdRequest_default_instance_;
class GetTodoItemsByTodoListIdResponse;
struct GetTodoItemsByTodoListIdResponseDefaultTypeInternal;
extern GetTodoItemsByTodoListIdResponseDefaultTypeInternal _GetTodoItemsByTodoListIdResponse_default_instance_;
class GetTodoItemsRequest;
struct GetTodoItemsRequestDefaultTypeInternal;
extern GetTodoItemsRequestDefaultTypeInternal _GetTodoItemsRequest_default_instance_;
class GetTodoItemsResponse;
struct GetTodoItemsResponseDefaultTypeInternal;
extern GetTodoItemsResponseDefaultTypeInternal _GetTodoItemsResponse_default_instance_;
class TodoItem;
struct TodoItemDefaultTypeInternal;
extern TodoItemDefaultTypeInternal _TodoItem_default_instance_;
class UpdateTodoItemRequest;
struct UpdateTodoItemRequestDefaultTypeInternal;
extern UpdateTodoItemRequestDefaultTypeInternal _UpdateTodoItemRequest_default_instance_;
class UpdateTodoItemResponse;
struct UpdateTodoItemResponseDefaultTypeInternal;
extern UpdateTodoItemResponseDefaultTypeInternal _UpdateTodoItemResponse_default_instance_;
}  // namespace todo_item
PROTOBUF_NAMESPACE_OPEN
template<> ::todo_item::CreateTodoItemRequest* Arena::CreateMaybeMessage<::todo_item::CreateTodoItemRequest>(Arena*);
template<> ::todo_item::CreateTodoItemResponse* Arena::CreateMaybeMessage<::todo_item::CreateTodoItemResponse>(Arena*);
template<> ::todo_item::DeleteTodoItemRequest* Arena::CreateMaybeMessage<::todo_item::DeleteTodoItemRequest>(Arena*);
template<> ::todo_item::DeleteTodoItemResponse* Arena::CreateMaybeMessage<::todo_item::DeleteTodoItemResponse>(Arena*);
template<> ::todo_item::GetTodoItemsByTodoListIdRequest* Arena::CreateMaybeMessage<::todo_item::GetTodoItemsByTodoListIdRequest>(Arena*);
template<> ::todo_item::GetTodoItemsByTodoListIdResponse* Arena::CreateMaybeMessage<::todo_item::GetTodoItemsByTodoListIdResponse>(Arena*);
template<> ::todo_item::GetTodoItemsRequest* Arena::CreateMaybeMessage<::todo_item::GetTodoItemsRequest>(Arena*);
template<> ::todo_item::GetTodoItemsResponse* Arena::CreateMaybeMessage<::todo_item::GetTodoItemsResponse>(Arena*);
template<> ::todo_item::TodoItem* Arena::CreateMaybeMessage<::todo_item::TodoItem>(Arena*);
template<> ::todo_item::UpdateTodoItemRequest* Arena::CreateMaybeMessage<::todo_item::UpdateTodoItemRequest>(Arena*);
template<> ::todo_item::UpdateTodoItemResponse* Arena::CreateMaybeMessage<::todo_item::UpdateTodoItemResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace todo_item {

// ===================================================================

class TodoItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.TodoItem) */ {
 public:
  inline TodoItem() : TodoItem(nullptr) {}
  ~TodoItem() override;
  explicit PROTOBUF_CONSTEXPR TodoItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TodoItem(const TodoItem& from);
  TodoItem(TodoItem&& from) noexcept
    : TodoItem() {
    *this = ::std::move(from);
  }

  inline TodoItem& operator=(const TodoItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TodoItem& operator=(TodoItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TodoItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TodoItem* internal_default_instance() {
    return reinterpret_cast<const TodoItem*>(
               &_TodoItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TodoItem& a, TodoItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TodoItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TodoItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TodoItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TodoItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TodoItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TodoItem& from) {
    TodoItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TodoItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.TodoItem";
  }
  protected:
  explicit TodoItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kNoteFieldNumber = 3,
    kTodoListIdFieldNumber = 4,
    kCreatedDateFieldNumber = 6,
    kModifiedDateFieldNumber = 7,
    kCompletedFieldNumber = 5,
    kVersionFieldNumber = 8,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string note = 3;
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string todo_list_id = 4;
  void clear_todo_list_id();
  const std::string& todo_list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_todo_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_todo_list_id();
  PROTOBUF_NODISCARD std::string* release_todo_list_id();
  void set_allocated_todo_list_id(std::string* todo_list_id);
  private:
  const std::string& _internal_todo_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_todo_list_id(const std::string& value);
  std::string* _internal_mutable_todo_list_id();
  public:

  // string created_date = 6;
  void clear_created_date();
  const std::string& created_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_created_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_created_date();
  PROTOBUF_NODISCARD std::string* release_created_date();
  void set_allocated_created_date(std::string* created_date);
  private:
  const std::string& _internal_created_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_created_date(const std::string& value);
  std::string* _internal_mutable_created_date();
  public:

  // string modified_date = 7;
  void clear_modified_date();
  const std::string& modified_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modified_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modified_date();
  PROTOBUF_NODISCARD std::string* release_modified_date();
  void set_allocated_modified_date(std::string* modified_date);
  private:
  const std::string& _internal_modified_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modified_date(const std::string& value);
  std::string* _internal_mutable_modified_date();
  public:

  // bool completed = 5;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // int32 version = 8;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.TodoItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr todo_list_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr created_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modified_date_;
    bool completed_;
    int32_t version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class GetTodoItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.GetTodoItemsRequest) */ {
 public:
  inline GetTodoItemsRequest() : GetTodoItemsRequest(nullptr) {}
  ~GetTodoItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTodoItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTodoItemsRequest(const GetTodoItemsRequest& from);
  GetTodoItemsRequest(GetTodoItemsRequest&& from) noexcept
    : GetTodoItemsRequest() {
    *this = ::std::move(from);
  }

  inline GetTodoItemsRequest& operator=(const GetTodoItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTodoItemsRequest& operator=(GetTodoItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTodoItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTodoItemsRequest* internal_default_instance() {
    return reinterpret_cast<const GetTodoItemsRequest*>(
               &_GetTodoItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetTodoItemsRequest& a, GetTodoItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTodoItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTodoItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTodoItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTodoItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTodoItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTodoItemsRequest& from) {
    GetTodoItemsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTodoItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.GetTodoItemsRequest";
  }
  protected:
  explicit GetTodoItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:todo_item.GetTodoItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class GetTodoItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.GetTodoItemsResponse) */ {
 public:
  inline GetTodoItemsResponse() : GetTodoItemsResponse(nullptr) {}
  ~GetTodoItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTodoItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTodoItemsResponse(const GetTodoItemsResponse& from);
  GetTodoItemsResponse(GetTodoItemsResponse&& from) noexcept
    : GetTodoItemsResponse() {
    *this = ::std::move(from);
  }

  inline GetTodoItemsResponse& operator=(const GetTodoItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTodoItemsResponse& operator=(GetTodoItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTodoItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTodoItemsResponse* internal_default_instance() {
    return reinterpret_cast<const GetTodoItemsResponse*>(
               &_GetTodoItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetTodoItemsResponse& a, GetTodoItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTodoItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTodoItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTodoItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTodoItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTodoItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTodoItemsResponse& from) {
    GetTodoItemsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTodoItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.GetTodoItemsResponse";
  }
  protected:
  explicit GetTodoItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kItemsFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .todo_item.TodoItem items = 1;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::todo_item::TodoItem& items() const;
  PROTOBUF_NODISCARD ::todo_item::TodoItem* release_items();
  ::todo_item::TodoItem* mutable_items();
  void set_allocated_items(::todo_item::TodoItem* items);
  private:
  const ::todo_item::TodoItem& _internal_items() const;
  ::todo_item::TodoItem* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::todo_item::TodoItem* items);
  ::todo_item::TodoItem* unsafe_arena_release_items();

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.GetTodoItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::todo_item::TodoItem* items_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class CreateTodoItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.CreateTodoItemRequest) */ {
 public:
  inline CreateTodoItemRequest() : CreateTodoItemRequest(nullptr) {}
  ~CreateTodoItemRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTodoItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTodoItemRequest(const CreateTodoItemRequest& from);
  CreateTodoItemRequest(CreateTodoItemRequest&& from) noexcept
    : CreateTodoItemRequest() {
    *this = ::std::move(from);
  }

  inline CreateTodoItemRequest& operator=(const CreateTodoItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTodoItemRequest& operator=(CreateTodoItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTodoItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTodoItemRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTodoItemRequest*>(
               &_CreateTodoItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateTodoItemRequest& a, CreateTodoItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTodoItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTodoItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTodoItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTodoItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTodoItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTodoItemRequest& from) {
    CreateTodoItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTodoItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.CreateTodoItemRequest";
  }
  protected:
  explicit CreateTodoItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kNoteFieldNumber = 2,
    kTodoListIdFieldNumber = 3,
    kCompletedFieldNumber = 4,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string note = 2;
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string todo_list_id = 3;
  void clear_todo_list_id();
  const std::string& todo_list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_todo_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_todo_list_id();
  PROTOBUF_NODISCARD std::string* release_todo_list_id();
  void set_allocated_todo_list_id(std::string* todo_list_id);
  private:
  const std::string& _internal_todo_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_todo_list_id(const std::string& value);
  std::string* _internal_mutable_todo_list_id();
  public:

  // bool completed = 4;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.CreateTodoItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr todo_list_id_;
    bool completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class CreateTodoItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.CreateTodoItemResponse) */ {
 public:
  inline CreateTodoItemResponse() : CreateTodoItemResponse(nullptr) {}
  ~CreateTodoItemResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateTodoItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTodoItemResponse(const CreateTodoItemResponse& from);
  CreateTodoItemResponse(CreateTodoItemResponse&& from) noexcept
    : CreateTodoItemResponse() {
    *this = ::std::move(from);
  }

  inline CreateTodoItemResponse& operator=(const CreateTodoItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTodoItemResponse& operator=(CreateTodoItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTodoItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTodoItemResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTodoItemResponse*>(
               &_CreateTodoItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateTodoItemResponse& a, CreateTodoItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTodoItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTodoItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTodoItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTodoItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTodoItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTodoItemResponse& from) {
    CreateTodoItemResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTodoItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.CreateTodoItemResponse";
  }
  protected:
  explicit CreateTodoItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMessageFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.CreateTodoItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class UpdateTodoItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.UpdateTodoItemRequest) */ {
 public:
  inline UpdateTodoItemRequest() : UpdateTodoItemRequest(nullptr) {}
  ~UpdateTodoItemRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateTodoItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTodoItemRequest(const UpdateTodoItemRequest& from);
  UpdateTodoItemRequest(UpdateTodoItemRequest&& from) noexcept
    : UpdateTodoItemRequest() {
    *this = ::std::move(from);
  }

  inline UpdateTodoItemRequest& operator=(const UpdateTodoItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTodoItemRequest& operator=(UpdateTodoItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTodoItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTodoItemRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateTodoItemRequest*>(
               &_UpdateTodoItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UpdateTodoItemRequest& a, UpdateTodoItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTodoItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTodoItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTodoItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTodoItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTodoItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTodoItemRequest& from) {
    UpdateTodoItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTodoItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.UpdateTodoItemRequest";
  }
  protected:
  explicit UpdateTodoItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kNoteFieldNumber = 3,
    kTodoListIdFieldNumber = 4,
    kCompletedFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string note = 3;
  void clear_note();
  const std::string& note() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_note(ArgT0&& arg0, ArgT... args);
  std::string* mutable_note();
  PROTOBUF_NODISCARD std::string* release_note();
  void set_allocated_note(std::string* note);
  private:
  const std::string& _internal_note() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_note(const std::string& value);
  std::string* _internal_mutable_note();
  public:

  // string todo_list_id = 4;
  void clear_todo_list_id();
  const std::string& todo_list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_todo_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_todo_list_id();
  PROTOBUF_NODISCARD std::string* release_todo_list_id();
  void set_allocated_todo_list_id(std::string* todo_list_id);
  private:
  const std::string& _internal_todo_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_todo_list_id(const std::string& value);
  std::string* _internal_mutable_todo_list_id();
  public:

  // bool completed = 5;
  void clear_completed();
  bool completed() const;
  void set_completed(bool value);
  private:
  bool _internal_completed() const;
  void _internal_set_completed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.UpdateTodoItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr note_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr todo_list_id_;
    bool completed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class UpdateTodoItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.UpdateTodoItemResponse) */ {
 public:
  inline UpdateTodoItemResponse() : UpdateTodoItemResponse(nullptr) {}
  ~UpdateTodoItemResponse() override;
  explicit PROTOBUF_CONSTEXPR UpdateTodoItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTodoItemResponse(const UpdateTodoItemResponse& from);
  UpdateTodoItemResponse(UpdateTodoItemResponse&& from) noexcept
    : UpdateTodoItemResponse() {
    *this = ::std::move(from);
  }

  inline UpdateTodoItemResponse& operator=(const UpdateTodoItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTodoItemResponse& operator=(UpdateTodoItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTodoItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTodoItemResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateTodoItemResponse*>(
               &_UpdateTodoItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateTodoItemResponse& a, UpdateTodoItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTodoItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTodoItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTodoItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTodoItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTodoItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateTodoItemResponse& from) {
    UpdateTodoItemResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTodoItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.UpdateTodoItemResponse";
  }
  protected:
  explicit UpdateTodoItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.UpdateTodoItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class DeleteTodoItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.DeleteTodoItemRequest) */ {
 public:
  inline DeleteTodoItemRequest() : DeleteTodoItemRequest(nullptr) {}
  ~DeleteTodoItemRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteTodoItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTodoItemRequest(const DeleteTodoItemRequest& from);
  DeleteTodoItemRequest(DeleteTodoItemRequest&& from) noexcept
    : DeleteTodoItemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTodoItemRequest& operator=(const DeleteTodoItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTodoItemRequest& operator=(DeleteTodoItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTodoItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTodoItemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTodoItemRequest*>(
               &_DeleteTodoItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteTodoItemRequest& a, DeleteTodoItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTodoItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTodoItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTodoItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteTodoItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTodoItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteTodoItemRequest& from) {
    DeleteTodoItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTodoItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.DeleteTodoItemRequest";
  }
  protected:
  explicit DeleteTodoItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:todo_item.DeleteTodoItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class DeleteTodoItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.DeleteTodoItemResponse) */ {
 public:
  inline DeleteTodoItemResponse() : DeleteTodoItemResponse(nullptr) {}
  ~DeleteTodoItemResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteTodoItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTodoItemResponse(const DeleteTodoItemResponse& from);
  DeleteTodoItemResponse(DeleteTodoItemResponse&& from) noexcept
    : DeleteTodoItemResponse() {
    *this = ::std::move(from);
  }

  inline DeleteTodoItemResponse& operator=(const DeleteTodoItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTodoItemResponse& operator=(DeleteTodoItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTodoItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTodoItemResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTodoItemResponse*>(
               &_DeleteTodoItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteTodoItemResponse& a, DeleteTodoItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTodoItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTodoItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTodoItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteTodoItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTodoItemResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteTodoItemResponse& from) {
    DeleteTodoItemResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTodoItemResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.DeleteTodoItemResponse";
  }
  protected:
  explicit DeleteTodoItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.DeleteTodoItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class GetTodoItemsByTodoListIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.GetTodoItemsByTodoListIdRequest) */ {
 public:
  inline GetTodoItemsByTodoListIdRequest() : GetTodoItemsByTodoListIdRequest(nullptr) {}
  ~GetTodoItemsByTodoListIdRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTodoItemsByTodoListIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTodoItemsByTodoListIdRequest(const GetTodoItemsByTodoListIdRequest& from);
  GetTodoItemsByTodoListIdRequest(GetTodoItemsByTodoListIdRequest&& from) noexcept
    : GetTodoItemsByTodoListIdRequest() {
    *this = ::std::move(from);
  }

  inline GetTodoItemsByTodoListIdRequest& operator=(const GetTodoItemsByTodoListIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTodoItemsByTodoListIdRequest& operator=(GetTodoItemsByTodoListIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTodoItemsByTodoListIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTodoItemsByTodoListIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetTodoItemsByTodoListIdRequest*>(
               &_GetTodoItemsByTodoListIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetTodoItemsByTodoListIdRequest& a, GetTodoItemsByTodoListIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTodoItemsByTodoListIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTodoItemsByTodoListIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTodoItemsByTodoListIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTodoItemsByTodoListIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTodoItemsByTodoListIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTodoItemsByTodoListIdRequest& from) {
    GetTodoItemsByTodoListIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTodoItemsByTodoListIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.GetTodoItemsByTodoListIdRequest";
  }
  protected:
  explicit GetTodoItemsByTodoListIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTodoListIdFieldNumber = 1,
  };
  // string todo_list_id = 1;
  void clear_todo_list_id();
  const std::string& todo_list_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_todo_list_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_todo_list_id();
  PROTOBUF_NODISCARD std::string* release_todo_list_id();
  void set_allocated_todo_list_id(std::string* todo_list_id);
  private:
  const std::string& _internal_todo_list_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_todo_list_id(const std::string& value);
  std::string* _internal_mutable_todo_list_id();
  public:

  // @@protoc_insertion_point(class_scope:todo_item.GetTodoItemsByTodoListIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr todo_list_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// -------------------------------------------------------------------

class GetTodoItemsByTodoListIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:todo_item.GetTodoItemsByTodoListIdResponse) */ {
 public:
  inline GetTodoItemsByTodoListIdResponse() : GetTodoItemsByTodoListIdResponse(nullptr) {}
  ~GetTodoItemsByTodoListIdResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTodoItemsByTodoListIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTodoItemsByTodoListIdResponse(const GetTodoItemsByTodoListIdResponse& from);
  GetTodoItemsByTodoListIdResponse(GetTodoItemsByTodoListIdResponse&& from) noexcept
    : GetTodoItemsByTodoListIdResponse() {
    *this = ::std::move(from);
  }

  inline GetTodoItemsByTodoListIdResponse& operator=(const GetTodoItemsByTodoListIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTodoItemsByTodoListIdResponse& operator=(GetTodoItemsByTodoListIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTodoItemsByTodoListIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTodoItemsByTodoListIdResponse* internal_default_instance() {
    return reinterpret_cast<const GetTodoItemsByTodoListIdResponse*>(
               &_GetTodoItemsByTodoListIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetTodoItemsByTodoListIdResponse& a, GetTodoItemsByTodoListIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTodoItemsByTodoListIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTodoItemsByTodoListIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTodoItemsByTodoListIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTodoItemsByTodoListIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTodoItemsByTodoListIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTodoItemsByTodoListIdResponse& from) {
    GetTodoItemsByTodoListIdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTodoItemsByTodoListIdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "todo_item.GetTodoItemsByTodoListIdResponse";
  }
  protected:
  explicit GetTodoItemsByTodoListIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kItemsFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .todo_item.TodoItem items = 1;
  bool has_items() const;
  private:
  bool _internal_has_items() const;
  public:
  void clear_items();
  const ::todo_item::TodoItem& items() const;
  PROTOBUF_NODISCARD ::todo_item::TodoItem* release_items();
  ::todo_item::TodoItem* mutable_items();
  void set_allocated_items(::todo_item::TodoItem* items);
  private:
  const ::todo_item::TodoItem& _internal_items() const;
  ::todo_item::TodoItem* _internal_mutable_items();
  public:
  void unsafe_arena_set_allocated_items(
      ::todo_item::TodoItem* items);
  ::todo_item::TodoItem* unsafe_arena_release_items();

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:todo_item.GetTodoItemsByTodoListIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::todo_item::TodoItem* items_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_todo_5fitem_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TodoItem

// string id = 1;
inline void TodoItem::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& TodoItem::id() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TodoItem::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.id)
}
inline std::string* TodoItem::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:todo_item.TodoItem.id)
  return _s;
}
inline const std::string& TodoItem::_internal_id() const {
  return _impl_.id_.Get();
}
inline void TodoItem::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* TodoItem::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* TodoItem::release_id() {
  // @@protoc_insertion_point(field_release:todo_item.TodoItem.id)
  return _impl_.id_.Release();
}
inline void TodoItem::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.TodoItem.id)
}

// string title = 2;
inline void TodoItem::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& TodoItem::title() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TodoItem::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.title)
}
inline std::string* TodoItem::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:todo_item.TodoItem.title)
  return _s;
}
inline const std::string& TodoItem::_internal_title() const {
  return _impl_.title_.Get();
}
inline void TodoItem::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* TodoItem::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* TodoItem::release_title() {
  // @@protoc_insertion_point(field_release:todo_item.TodoItem.title)
  return _impl_.title_.Release();
}
inline void TodoItem::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.TodoItem.title)
}

// string note = 3;
inline void TodoItem::clear_note() {
  _impl_.note_.ClearToEmpty();
}
inline const std::string& TodoItem::note() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TodoItem::set_note(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.note)
}
inline std::string* TodoItem::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:todo_item.TodoItem.note)
  return _s;
}
inline const std::string& TodoItem::_internal_note() const {
  return _impl_.note_.Get();
}
inline void TodoItem::_internal_set_note(const std::string& value) {
  
  _impl_.note_.Set(value, GetArenaForAllocation());
}
inline std::string* TodoItem::_internal_mutable_note() {
  
  return _impl_.note_.Mutable(GetArenaForAllocation());
}
inline std::string* TodoItem::release_note() {
  // @@protoc_insertion_point(field_release:todo_item.TodoItem.note)
  return _impl_.note_.Release();
}
inline void TodoItem::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  _impl_.note_.SetAllocated(note, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.TodoItem.note)
}

// string todo_list_id = 4;
inline void TodoItem::clear_todo_list_id() {
  _impl_.todo_list_id_.ClearToEmpty();
}
inline const std::string& TodoItem::todo_list_id() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.todo_list_id)
  return _internal_todo_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TodoItem::set_todo_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.todo_list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.todo_list_id)
}
inline std::string* TodoItem::mutable_todo_list_id() {
  std::string* _s = _internal_mutable_todo_list_id();
  // @@protoc_insertion_point(field_mutable:todo_item.TodoItem.todo_list_id)
  return _s;
}
inline const std::string& TodoItem::_internal_todo_list_id() const {
  return _impl_.todo_list_id_.Get();
}
inline void TodoItem::_internal_set_todo_list_id(const std::string& value) {
  
  _impl_.todo_list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TodoItem::_internal_mutable_todo_list_id() {
  
  return _impl_.todo_list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TodoItem::release_todo_list_id() {
  // @@protoc_insertion_point(field_release:todo_item.TodoItem.todo_list_id)
  return _impl_.todo_list_id_.Release();
}
inline void TodoItem::set_allocated_todo_list_id(std::string* todo_list_id) {
  if (todo_list_id != nullptr) {
    
  } else {
    
  }
  _impl_.todo_list_id_.SetAllocated(todo_list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.todo_list_id_.IsDefault()) {
    _impl_.todo_list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.TodoItem.todo_list_id)
}

// bool completed = 5;
inline void TodoItem::clear_completed() {
  _impl_.completed_ = false;
}
inline bool TodoItem::_internal_completed() const {
  return _impl_.completed_;
}
inline bool TodoItem::completed() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.completed)
  return _internal_completed();
}
inline void TodoItem::_internal_set_completed(bool value) {
  
  _impl_.completed_ = value;
}
inline void TodoItem::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.completed)
}

// string created_date = 6;
inline void TodoItem::clear_created_date() {
  _impl_.created_date_.ClearToEmpty();
}
inline const std::string& TodoItem::created_date() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.created_date)
  return _internal_created_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TodoItem::set_created_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.created_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.created_date)
}
inline std::string* TodoItem::mutable_created_date() {
  std::string* _s = _internal_mutable_created_date();
  // @@protoc_insertion_point(field_mutable:todo_item.TodoItem.created_date)
  return _s;
}
inline const std::string& TodoItem::_internal_created_date() const {
  return _impl_.created_date_.Get();
}
inline void TodoItem::_internal_set_created_date(const std::string& value) {
  
  _impl_.created_date_.Set(value, GetArenaForAllocation());
}
inline std::string* TodoItem::_internal_mutable_created_date() {
  
  return _impl_.created_date_.Mutable(GetArenaForAllocation());
}
inline std::string* TodoItem::release_created_date() {
  // @@protoc_insertion_point(field_release:todo_item.TodoItem.created_date)
  return _impl_.created_date_.Release();
}
inline void TodoItem::set_allocated_created_date(std::string* created_date) {
  if (created_date != nullptr) {
    
  } else {
    
  }
  _impl_.created_date_.SetAllocated(created_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.created_date_.IsDefault()) {
    _impl_.created_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.TodoItem.created_date)
}

// string modified_date = 7;
inline void TodoItem::clear_modified_date() {
  _impl_.modified_date_.ClearToEmpty();
}
inline const std::string& TodoItem::modified_date() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.modified_date)
  return _internal_modified_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TodoItem::set_modified_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.modified_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.modified_date)
}
inline std::string* TodoItem::mutable_modified_date() {
  std::string* _s = _internal_mutable_modified_date();
  // @@protoc_insertion_point(field_mutable:todo_item.TodoItem.modified_date)
  return _s;
}
inline const std::string& TodoItem::_internal_modified_date() const {
  return _impl_.modified_date_.Get();
}
inline void TodoItem::_internal_set_modified_date(const std::string& value) {
  
  _impl_.modified_date_.Set(value, GetArenaForAllocation());
}
inline std::string* TodoItem::_internal_mutable_modified_date() {
  
  return _impl_.modified_date_.Mutable(GetArenaForAllocation());
}
inline std::string* TodoItem::release_modified_date() {
  // @@protoc_insertion_point(field_release:todo_item.TodoItem.modified_date)
  return _impl_.modified_date_.Release();
}
inline void TodoItem::set_allocated_modified_date(std::string* modified_date) {
  if (modified_date != nullptr) {
    
  } else {
    
  }
  _impl_.modified_date_.SetAllocated(modified_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.modified_date_.IsDefault()) {
    _impl_.modified_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.TodoItem.modified_date)
}

// int32 version = 8;
inline void TodoItem::clear_version() {
  _impl_.version_ = 0;
}
inline int32_t TodoItem::_internal_version() const {
  return _impl_.version_;
}
inline int32_t TodoItem::version() const {
  // @@protoc_insertion_point(field_get:todo_item.TodoItem.version)
  return _internal_version();
}
inline void TodoItem::_internal_set_version(int32_t value) {
  
  _impl_.version_ = value;
}
inline void TodoItem::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:todo_item.TodoItem.version)
}

// -------------------------------------------------------------------

// GetTodoItemsRequest

// string id = 1;
inline void GetTodoItemsRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetTodoItemsRequest::id() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTodoItemsRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.GetTodoItemsRequest.id)
}
inline std::string* GetTodoItemsRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:todo_item.GetTodoItemsRequest.id)
  return _s;
}
inline const std::string& GetTodoItemsRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GetTodoItemsRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTodoItemsRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTodoItemsRequest::release_id() {
  // @@protoc_insertion_point(field_release:todo_item.GetTodoItemsRequest.id)
  return _impl_.id_.Release();
}
inline void GetTodoItemsRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.GetTodoItemsRequest.id)
}

// -------------------------------------------------------------------

// GetTodoItemsResponse

// .todo_item.TodoItem items = 1;
inline bool GetTodoItemsResponse::_internal_has_items() const {
  return this != internal_default_instance() && _impl_.items_ != nullptr;
}
inline bool GetTodoItemsResponse::has_items() const {
  return _internal_has_items();
}
inline void GetTodoItemsResponse::clear_items() {
  if (GetArenaForAllocation() == nullptr && _impl_.items_ != nullptr) {
    delete _impl_.items_;
  }
  _impl_.items_ = nullptr;
}
inline const ::todo_item::TodoItem& GetTodoItemsResponse::_internal_items() const {
  const ::todo_item::TodoItem* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::todo_item::TodoItem&>(
      ::todo_item::_TodoItem_default_instance_);
}
inline const ::todo_item::TodoItem& GetTodoItemsResponse::items() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsResponse.items)
  return _internal_items();
}
inline void GetTodoItemsResponse::unsafe_arena_set_allocated_items(
    ::todo_item::TodoItem* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = items;
  if (items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:todo_item.GetTodoItemsResponse.items)
}
inline ::todo_item::TodoItem* GetTodoItemsResponse::release_items() {
  
  ::todo_item::TodoItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::todo_item::TodoItem* GetTodoItemsResponse::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:todo_item.GetTodoItemsResponse.items)
  
  ::todo_item::TodoItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::todo_item::TodoItem* GetTodoItemsResponse::_internal_mutable_items() {
  
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::todo_item::TodoItem>(GetArenaForAllocation());
    _impl_.items_ = p;
  }
  return _impl_.items_;
}
inline ::todo_item::TodoItem* GetTodoItemsResponse::mutable_items() {
  ::todo_item::TodoItem* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:todo_item.GetTodoItemsResponse.items)
  return _msg;
}
inline void GetTodoItemsResponse::set_allocated_items(::todo_item::TodoItem* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.items_;
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(items);
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.items_ = items;
  // @@protoc_insertion_point(field_set_allocated:todo_item.GetTodoItemsResponse.items)
}

// int32 status = 2;
inline void GetTodoItemsResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t GetTodoItemsResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t GetTodoItemsResponse::status() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsResponse.status)
  return _internal_status();
}
inline void GetTodoItemsResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void GetTodoItemsResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:todo_item.GetTodoItemsResponse.status)
}

// string message = 3;
inline void GetTodoItemsResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetTodoItemsResponse::message() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTodoItemsResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.GetTodoItemsResponse.message)
}
inline std::string* GetTodoItemsResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:todo_item.GetTodoItemsResponse.message)
  return _s;
}
inline const std::string& GetTodoItemsResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetTodoItemsResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTodoItemsResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTodoItemsResponse::release_message() {
  // @@protoc_insertion_point(field_release:todo_item.GetTodoItemsResponse.message)
  return _impl_.message_.Release();
}
inline void GetTodoItemsResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.GetTodoItemsResponse.message)
}

// -------------------------------------------------------------------

// CreateTodoItemRequest

// string title = 1;
inline void CreateTodoItemRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& CreateTodoItemRequest::title() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTodoItemRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemRequest.title)
}
inline std::string* CreateTodoItemRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:todo_item.CreateTodoItemRequest.title)
  return _s;
}
inline const std::string& CreateTodoItemRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void CreateTodoItemRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTodoItemRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTodoItemRequest::release_title() {
  // @@protoc_insertion_point(field_release:todo_item.CreateTodoItemRequest.title)
  return _impl_.title_.Release();
}
inline void CreateTodoItemRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.CreateTodoItemRequest.title)
}

// string note = 2;
inline void CreateTodoItemRequest::clear_note() {
  _impl_.note_.ClearToEmpty();
}
inline const std::string& CreateTodoItemRequest::note() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemRequest.note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTodoItemRequest::set_note(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemRequest.note)
}
inline std::string* CreateTodoItemRequest::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:todo_item.CreateTodoItemRequest.note)
  return _s;
}
inline const std::string& CreateTodoItemRequest::_internal_note() const {
  return _impl_.note_.Get();
}
inline void CreateTodoItemRequest::_internal_set_note(const std::string& value) {
  
  _impl_.note_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTodoItemRequest::_internal_mutable_note() {
  
  return _impl_.note_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTodoItemRequest::release_note() {
  // @@protoc_insertion_point(field_release:todo_item.CreateTodoItemRequest.note)
  return _impl_.note_.Release();
}
inline void CreateTodoItemRequest::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  _impl_.note_.SetAllocated(note, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.CreateTodoItemRequest.note)
}

// string todo_list_id = 3;
inline void CreateTodoItemRequest::clear_todo_list_id() {
  _impl_.todo_list_id_.ClearToEmpty();
}
inline const std::string& CreateTodoItemRequest::todo_list_id() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemRequest.todo_list_id)
  return _internal_todo_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTodoItemRequest::set_todo_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.todo_list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemRequest.todo_list_id)
}
inline std::string* CreateTodoItemRequest::mutable_todo_list_id() {
  std::string* _s = _internal_mutable_todo_list_id();
  // @@protoc_insertion_point(field_mutable:todo_item.CreateTodoItemRequest.todo_list_id)
  return _s;
}
inline const std::string& CreateTodoItemRequest::_internal_todo_list_id() const {
  return _impl_.todo_list_id_.Get();
}
inline void CreateTodoItemRequest::_internal_set_todo_list_id(const std::string& value) {
  
  _impl_.todo_list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTodoItemRequest::_internal_mutable_todo_list_id() {
  
  return _impl_.todo_list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTodoItemRequest::release_todo_list_id() {
  // @@protoc_insertion_point(field_release:todo_item.CreateTodoItemRequest.todo_list_id)
  return _impl_.todo_list_id_.Release();
}
inline void CreateTodoItemRequest::set_allocated_todo_list_id(std::string* todo_list_id) {
  if (todo_list_id != nullptr) {
    
  } else {
    
  }
  _impl_.todo_list_id_.SetAllocated(todo_list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.todo_list_id_.IsDefault()) {
    _impl_.todo_list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.CreateTodoItemRequest.todo_list_id)
}

// bool completed = 4;
inline void CreateTodoItemRequest::clear_completed() {
  _impl_.completed_ = false;
}
inline bool CreateTodoItemRequest::_internal_completed() const {
  return _impl_.completed_;
}
inline bool CreateTodoItemRequest::completed() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemRequest.completed)
  return _internal_completed();
}
inline void CreateTodoItemRequest::_internal_set_completed(bool value) {
  
  _impl_.completed_ = value;
}
inline void CreateTodoItemRequest::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemRequest.completed)
}

// -------------------------------------------------------------------

// CreateTodoItemResponse

// string id = 1;
inline void CreateTodoItemResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& CreateTodoItemResponse::id() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTodoItemResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemResponse.id)
}
inline std::string* CreateTodoItemResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:todo_item.CreateTodoItemResponse.id)
  return _s;
}
inline const std::string& CreateTodoItemResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CreateTodoItemResponse::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTodoItemResponse::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTodoItemResponse::release_id() {
  // @@protoc_insertion_point(field_release:todo_item.CreateTodoItemResponse.id)
  return _impl_.id_.Release();
}
inline void CreateTodoItemResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.CreateTodoItemResponse.id)
}

// int32 status = 2;
inline void CreateTodoItemResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t CreateTodoItemResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t CreateTodoItemResponse::status() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemResponse.status)
  return _internal_status();
}
inline void CreateTodoItemResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void CreateTodoItemResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemResponse.status)
}

// string message = 3;
inline void CreateTodoItemResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& CreateTodoItemResponse::message() const {
  // @@protoc_insertion_point(field_get:todo_item.CreateTodoItemResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTodoItemResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.CreateTodoItemResponse.message)
}
inline std::string* CreateTodoItemResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:todo_item.CreateTodoItemResponse.message)
  return _s;
}
inline const std::string& CreateTodoItemResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CreateTodoItemResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTodoItemResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTodoItemResponse::release_message() {
  // @@protoc_insertion_point(field_release:todo_item.CreateTodoItemResponse.message)
  return _impl_.message_.Release();
}
inline void CreateTodoItemResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.CreateTodoItemResponse.message)
}

// -------------------------------------------------------------------

// UpdateTodoItemRequest

// string id = 1;
inline void UpdateTodoItemRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& UpdateTodoItemRequest::id() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTodoItemRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemRequest.id)
}
inline std::string* UpdateTodoItemRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:todo_item.UpdateTodoItemRequest.id)
  return _s;
}
inline const std::string& UpdateTodoItemRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void UpdateTodoItemRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::release_id() {
  // @@protoc_insertion_point(field_release:todo_item.UpdateTodoItemRequest.id)
  return _impl_.id_.Release();
}
inline void UpdateTodoItemRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.UpdateTodoItemRequest.id)
}

// string title = 2;
inline void UpdateTodoItemRequest::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& UpdateTodoItemRequest::title() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTodoItemRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemRequest.title)
}
inline std::string* UpdateTodoItemRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:todo_item.UpdateTodoItemRequest.title)
  return _s;
}
inline const std::string& UpdateTodoItemRequest::_internal_title() const {
  return _impl_.title_.Get();
}
inline void UpdateTodoItemRequest::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::release_title() {
  // @@protoc_insertion_point(field_release:todo_item.UpdateTodoItemRequest.title)
  return _impl_.title_.Release();
}
inline void UpdateTodoItemRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.UpdateTodoItemRequest.title)
}

// string note = 3;
inline void UpdateTodoItemRequest::clear_note() {
  _impl_.note_.ClearToEmpty();
}
inline const std::string& UpdateTodoItemRequest::note() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemRequest.note)
  return _internal_note();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTodoItemRequest::set_note(ArgT0&& arg0, ArgT... args) {
 
 _impl_.note_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemRequest.note)
}
inline std::string* UpdateTodoItemRequest::mutable_note() {
  std::string* _s = _internal_mutable_note();
  // @@protoc_insertion_point(field_mutable:todo_item.UpdateTodoItemRequest.note)
  return _s;
}
inline const std::string& UpdateTodoItemRequest::_internal_note() const {
  return _impl_.note_.Get();
}
inline void UpdateTodoItemRequest::_internal_set_note(const std::string& value) {
  
  _impl_.note_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::_internal_mutable_note() {
  
  return _impl_.note_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::release_note() {
  // @@protoc_insertion_point(field_release:todo_item.UpdateTodoItemRequest.note)
  return _impl_.note_.Release();
}
inline void UpdateTodoItemRequest::set_allocated_note(std::string* note) {
  if (note != nullptr) {
    
  } else {
    
  }
  _impl_.note_.SetAllocated(note, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.note_.IsDefault()) {
    _impl_.note_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.UpdateTodoItemRequest.note)
}

// string todo_list_id = 4;
inline void UpdateTodoItemRequest::clear_todo_list_id() {
  _impl_.todo_list_id_.ClearToEmpty();
}
inline const std::string& UpdateTodoItemRequest::todo_list_id() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemRequest.todo_list_id)
  return _internal_todo_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTodoItemRequest::set_todo_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.todo_list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemRequest.todo_list_id)
}
inline std::string* UpdateTodoItemRequest::mutable_todo_list_id() {
  std::string* _s = _internal_mutable_todo_list_id();
  // @@protoc_insertion_point(field_mutable:todo_item.UpdateTodoItemRequest.todo_list_id)
  return _s;
}
inline const std::string& UpdateTodoItemRequest::_internal_todo_list_id() const {
  return _impl_.todo_list_id_.Get();
}
inline void UpdateTodoItemRequest::_internal_set_todo_list_id(const std::string& value) {
  
  _impl_.todo_list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::_internal_mutable_todo_list_id() {
  
  return _impl_.todo_list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTodoItemRequest::release_todo_list_id() {
  // @@protoc_insertion_point(field_release:todo_item.UpdateTodoItemRequest.todo_list_id)
  return _impl_.todo_list_id_.Release();
}
inline void UpdateTodoItemRequest::set_allocated_todo_list_id(std::string* todo_list_id) {
  if (todo_list_id != nullptr) {
    
  } else {
    
  }
  _impl_.todo_list_id_.SetAllocated(todo_list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.todo_list_id_.IsDefault()) {
    _impl_.todo_list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.UpdateTodoItemRequest.todo_list_id)
}

// bool completed = 5;
inline void UpdateTodoItemRequest::clear_completed() {
  _impl_.completed_ = false;
}
inline bool UpdateTodoItemRequest::_internal_completed() const {
  return _impl_.completed_;
}
inline bool UpdateTodoItemRequest::completed() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemRequest.completed)
  return _internal_completed();
}
inline void UpdateTodoItemRequest::_internal_set_completed(bool value) {
  
  _impl_.completed_ = value;
}
inline void UpdateTodoItemRequest::set_completed(bool value) {
  _internal_set_completed(value);
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemRequest.completed)
}

// -------------------------------------------------------------------

// UpdateTodoItemResponse

// int32 status = 1;
inline void UpdateTodoItemResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t UpdateTodoItemResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t UpdateTodoItemResponse::status() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemResponse.status)
  return _internal_status();
}
inline void UpdateTodoItemResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void UpdateTodoItemResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemResponse.status)
}

// string message = 2;
inline void UpdateTodoItemResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& UpdateTodoItemResponse::message() const {
  // @@protoc_insertion_point(field_get:todo_item.UpdateTodoItemResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateTodoItemResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.UpdateTodoItemResponse.message)
}
inline std::string* UpdateTodoItemResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:todo_item.UpdateTodoItemResponse.message)
  return _s;
}
inline const std::string& UpdateTodoItemResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void UpdateTodoItemResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateTodoItemResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateTodoItemResponse::release_message() {
  // @@protoc_insertion_point(field_release:todo_item.UpdateTodoItemResponse.message)
  return _impl_.message_.Release();
}
inline void UpdateTodoItemResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.UpdateTodoItemResponse.message)
}

// -------------------------------------------------------------------

// DeleteTodoItemRequest

// string id = 1;
inline void DeleteTodoItemRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteTodoItemRequest::id() const {
  // @@protoc_insertion_point(field_get:todo_item.DeleteTodoItemRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTodoItemRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.DeleteTodoItemRequest.id)
}
inline std::string* DeleteTodoItemRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:todo_item.DeleteTodoItemRequest.id)
  return _s;
}
inline const std::string& DeleteTodoItemRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeleteTodoItemRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteTodoItemRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteTodoItemRequest::release_id() {
  // @@protoc_insertion_point(field_release:todo_item.DeleteTodoItemRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteTodoItemRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.DeleteTodoItemRequest.id)
}

// -------------------------------------------------------------------

// DeleteTodoItemResponse

// int32 status = 1;
inline void DeleteTodoItemResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t DeleteTodoItemResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t DeleteTodoItemResponse::status() const {
  // @@protoc_insertion_point(field_get:todo_item.DeleteTodoItemResponse.status)
  return _internal_status();
}
inline void DeleteTodoItemResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void DeleteTodoItemResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:todo_item.DeleteTodoItemResponse.status)
}

// string message = 2;
inline void DeleteTodoItemResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DeleteTodoItemResponse::message() const {
  // @@protoc_insertion_point(field_get:todo_item.DeleteTodoItemResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTodoItemResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.DeleteTodoItemResponse.message)
}
inline std::string* DeleteTodoItemResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:todo_item.DeleteTodoItemResponse.message)
  return _s;
}
inline const std::string& DeleteTodoItemResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DeleteTodoItemResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteTodoItemResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteTodoItemResponse::release_message() {
  // @@protoc_insertion_point(field_release:todo_item.DeleteTodoItemResponse.message)
  return _impl_.message_.Release();
}
inline void DeleteTodoItemResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.DeleteTodoItemResponse.message)
}

// -------------------------------------------------------------------

// GetTodoItemsByTodoListIdRequest

// string todo_list_id = 1;
inline void GetTodoItemsByTodoListIdRequest::clear_todo_list_id() {
  _impl_.todo_list_id_.ClearToEmpty();
}
inline const std::string& GetTodoItemsByTodoListIdRequest::todo_list_id() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsByTodoListIdRequest.todo_list_id)
  return _internal_todo_list_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTodoItemsByTodoListIdRequest::set_todo_list_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.todo_list_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.GetTodoItemsByTodoListIdRequest.todo_list_id)
}
inline std::string* GetTodoItemsByTodoListIdRequest::mutable_todo_list_id() {
  std::string* _s = _internal_mutable_todo_list_id();
  // @@protoc_insertion_point(field_mutable:todo_item.GetTodoItemsByTodoListIdRequest.todo_list_id)
  return _s;
}
inline const std::string& GetTodoItemsByTodoListIdRequest::_internal_todo_list_id() const {
  return _impl_.todo_list_id_.Get();
}
inline void GetTodoItemsByTodoListIdRequest::_internal_set_todo_list_id(const std::string& value) {
  
  _impl_.todo_list_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTodoItemsByTodoListIdRequest::_internal_mutable_todo_list_id() {
  
  return _impl_.todo_list_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTodoItemsByTodoListIdRequest::release_todo_list_id() {
  // @@protoc_insertion_point(field_release:todo_item.GetTodoItemsByTodoListIdRequest.todo_list_id)
  return _impl_.todo_list_id_.Release();
}
inline void GetTodoItemsByTodoListIdRequest::set_allocated_todo_list_id(std::string* todo_list_id) {
  if (todo_list_id != nullptr) {
    
  } else {
    
  }
  _impl_.todo_list_id_.SetAllocated(todo_list_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.todo_list_id_.IsDefault()) {
    _impl_.todo_list_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.GetTodoItemsByTodoListIdRequest.todo_list_id)
}

// -------------------------------------------------------------------

// GetTodoItemsByTodoListIdResponse

// .todo_item.TodoItem items = 1;
inline bool GetTodoItemsByTodoListIdResponse::_internal_has_items() const {
  return this != internal_default_instance() && _impl_.items_ != nullptr;
}
inline bool GetTodoItemsByTodoListIdResponse::has_items() const {
  return _internal_has_items();
}
inline void GetTodoItemsByTodoListIdResponse::clear_items() {
  if (GetArenaForAllocation() == nullptr && _impl_.items_ != nullptr) {
    delete _impl_.items_;
  }
  _impl_.items_ = nullptr;
}
inline const ::todo_item::TodoItem& GetTodoItemsByTodoListIdResponse::_internal_items() const {
  const ::todo_item::TodoItem* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::todo_item::TodoItem&>(
      ::todo_item::_TodoItem_default_instance_);
}
inline const ::todo_item::TodoItem& GetTodoItemsByTodoListIdResponse::items() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsByTodoListIdResponse.items)
  return _internal_items();
}
inline void GetTodoItemsByTodoListIdResponse::unsafe_arena_set_allocated_items(
    ::todo_item::TodoItem* items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = items;
  if (items) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:todo_item.GetTodoItemsByTodoListIdResponse.items)
}
inline ::todo_item::TodoItem* GetTodoItemsByTodoListIdResponse::release_items() {
  
  ::todo_item::TodoItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::todo_item::TodoItem* GetTodoItemsByTodoListIdResponse::unsafe_arena_release_items() {
  // @@protoc_insertion_point(field_release:todo_item.GetTodoItemsByTodoListIdResponse.items)
  
  ::todo_item::TodoItem* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::todo_item::TodoItem* GetTodoItemsByTodoListIdResponse::_internal_mutable_items() {
  
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::todo_item::TodoItem>(GetArenaForAllocation());
    _impl_.items_ = p;
  }
  return _impl_.items_;
}
inline ::todo_item::TodoItem* GetTodoItemsByTodoListIdResponse::mutable_items() {
  ::todo_item::TodoItem* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:todo_item.GetTodoItemsByTodoListIdResponse.items)
  return _msg;
}
inline void GetTodoItemsByTodoListIdResponse::set_allocated_items(::todo_item::TodoItem* items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.items_;
  }
  if (items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(items);
    if (message_arena != submessage_arena) {
      items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, items, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.items_ = items;
  // @@protoc_insertion_point(field_set_allocated:todo_item.GetTodoItemsByTodoListIdResponse.items)
}

// int32 status = 2;
inline void GetTodoItemsByTodoListIdResponse::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t GetTodoItemsByTodoListIdResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t GetTodoItemsByTodoListIdResponse::status() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsByTodoListIdResponse.status)
  return _internal_status();
}
inline void GetTodoItemsByTodoListIdResponse::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void GetTodoItemsByTodoListIdResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:todo_item.GetTodoItemsByTodoListIdResponse.status)
}

// string message = 3;
inline void GetTodoItemsByTodoListIdResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GetTodoItemsByTodoListIdResponse::message() const {
  // @@protoc_insertion_point(field_get:todo_item.GetTodoItemsByTodoListIdResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTodoItemsByTodoListIdResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:todo_item.GetTodoItemsByTodoListIdResponse.message)
}
inline std::string* GetTodoItemsByTodoListIdResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:todo_item.GetTodoItemsByTodoListIdResponse.message)
  return _s;
}
inline const std::string& GetTodoItemsByTodoListIdResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void GetTodoItemsByTodoListIdResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTodoItemsByTodoListIdResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTodoItemsByTodoListIdResponse::release_message() {
  // @@protoc_insertion_point(field_release:todo_item.GetTodoItemsByTodoListIdResponse.message)
  return _impl_.message_.Release();
}
inline void GetTodoItemsByTodoListIdResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:todo_item.GetTodoItemsByTodoListIdResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace todo_item

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_todo_5fitem_2eproto
